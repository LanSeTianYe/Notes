时间： 2020-08-19 11:44:44

参考：

1. 《RabbitMQ实战》

## 简介
消息队列。

消息接收方式：服务器主动推送。

通过组合交换器、队列、和绑定的组合，实现消费场景灵活配置。

**消息流转过程：**

生产者发送消息到 `RabbitMQ服务器`，消息经交换器发送到 绑定到交换器的符合指定匹配规则的队列，如果是持久化消息，`RabbitMQ服务器`会把消息持久化到磁盘，之后会响应生产者。

消费者从队列读取消息，消费消息，确认消息已经消费，消息从服务器删除。

### 消息

发送到消息队列的数据。

消息持久化要满足持久化交换器、持久化队列和持久化消息这三个条件，任何一个条件不满足都会导致消息丢失。当服务器宕机重启之后，重放持久化日志，把消息发送到交换器、或者队列。

### 生产者

发送消息到消息队列。

持久化消息：需要生产者发送的时候传递 `delivery_mode=2`，服务器会在消息写入到持久化日志之后响应。当服务器宕机重启之后没有处理完成的持久化消息会重新发送到交换器或队列。

发送方确认：发送消息时需要指定交换器、路由键和绑定。当开启发送方确认模式之后，`RabbitMQ服务器`会在消息发送给所有匹配的队列之后异步发送确认消息给发送方。如果队列是持久化的，则会在消息写入磁盘之后响应。

持久化消息：在服务器宕机重启之后会重放持久化日志，把消息发送到对应的交换器或队列。
持久化队列：只能保证队列存在，宕机重启之后队列中的消息将消息。
发送方确认：只能保证消息被发送到队列，如果消息不是持久化的，宕机重启之后队列消息会清空。

异步响应参数如下：

* `deliveryTag`：发送的第一条消息的 `deliveryTag` 是1，第二条是2，依次类推。
* `multiple`：是否同时确认多个，小于等于 deliveryTag 的消息都确认。

### 消费者

从消息队列取走数据。

* 接收消息：消费者可以持续接收或一次接收一个消息。
* 拒绝消息：消费者可以主动拒绝接收的消息，根据传递的参数不同，拒绝之后的消息会被发送给其他消费，或者发送到死信队列。
* 确认消息：当设置自动确认为false时，消费者需要向服务器发送确认信息。没有确认的消息会在消费者断开连接之后再次发送给队列的订阅者。在消费者发送确认消息之前，服务器不会再次向该消费者发送消息。
* 多消费者：当多个消费者订阅同一个队列时，队列中的消息会以轮询的方式发送给其中一个消费者。

### 交换器

消息到达`RabbitMQ服务器`后经交换器，发送到对应的队列。不同类型的交换器匹配规则不同。`RabbitMQ服务器`有一个默认的名字为空的 direct 类型的交换器，所有的队列都会绑定到该交换器，路由键是队列的名字。

**交换器类型:**

* direct：绑定的队列接收消息路由键和队列绑定的路由键相等的消息。
* fanout：绑定队列接收绑定交换器的所有消息。
* topic：绑定队列接收消息路由键和队列绑定路由规则匹配的消息。

    ```shell
    # 正确的列子
    fruit_queue       队列 绑定键 fruit.*.*     接收 fruit. 开头的消息
    fruit_red_queue   队列 绑定键 fruit.*.red   接收 fruit. 开头 .red 结尾 的消息
    fruit_apple_queue 队列 绑定键 fruit.apple.* 接收 fruit.apple. 开头的消息
    red_queue         队列 绑定键 *.*.red       接收 fruit. 开头的消息
    topic_all_queue   队列 绑定键 #             接收 所有的消息
    # 错误的列子
    fruit_a_red_queue   队列 绑定键 fruit.a*.red   接收不到任何消息
    ```

* headers：性能较低，不推荐使用。

### 队列

消息发送到`RabbitMQ服务器`之后，通过交换器根据绑定规则最终路由到队列，等待消费者消费。

* 创建队列。创建队列的时候如果不指定队列名称，服务器会自动分配一个名字，并返回。如果队列已存在则不会再次创建，如果队列已经存在但是创建时指定的参数不一样则会创建失败。
* 临时队列：队列可以配置自动删除，当没有消费者订阅的时候自动删除。
* 死信队列：消费者拒绝的直接删除的消息会放在死信队列。
* 私有队列：当前客户端连接可用，连接断开自动删除。
* 多消费者：当多个消费者订阅同一个队列时，队列中的消息会以轮询的方式发送给其中一个消费者。
* 队列自动删除：没有消费者订阅的时候自动删除队列。
* 队列绑定多个交换器。队列可以绑定到多个交换器，每个交换器符合匹配规则的消息都会发送到该队列。
* 默认绑定：队列默认会绑定到默认的 direct 交换器。路由键是队列的名字。

### 通道

客户端和`RabbitMQ服务器`建立连接之后，在单个TCP连接内建立信道进行数据交互。减少建立TCP连接的个数。提高性能。

### vhost

虚拟主机，不同的vhost相互隔离，每个vhost都拥有自己的的交换器、队列和绑定。vhost可以迁移到其它服务器上。客户端在建立连接时指定 vhost，用户只能访问有权限的 vhsot。

### 集群

假设有 `A(磁盘节点)`、`B(磁盘节点)`、`C(内存节点)`三个Rabbit服务器组成集群。集群中每一个节点都有 交换器、队列和绑定的全部元数据。磁盘节点需要把元数据同步到磁盘中，内存节点只把元数据存储在内存中。在集群中创建交换器、队列、绑定的时候，所有的存活的磁盘节点保存成功之后创建完成，如果没有磁盘节点则不能创建和修改这些信息。向磁盘中保存会耗费一定的时间，因此集群中注意磁盘节点的数量。

在集群中如果队列是持久化的，当队列所在的那个节点异常之后，则不能再创建原来的队列，需要等到原节点重新加入之后才能创建。如果队列不是持久化的，则节点异常之后，队列数据消失，此时可以在其它节点创建原来的队列。

镜像队列，创建队列的时候可以指定镜像队列的位置，指定之后对应的机器上会有一份该队列的备份，当主队列不能使用的时候，镜像队列会替代主队列提供服务。

### Warren

高可用机制，不同于集群。同一时间只有一个节点提供服务，当节点异常之后，其它的节点会替代异常节点提供服务，所有节点有相同的元数据。

### Shavel

Rabbit 服务之间的数据同步插件，将数据从一个服务器同步到另一个服务器。





