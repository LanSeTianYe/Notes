##
日期：2016/11/21 7:33:37  
参考文章：  
1. [如何正确地处理时间](http://www.liaoxuefeng.com/article/0014132675721847f569c3514034f099477472c73b5dee2000)  
2. [选择合适的 MySQL 日期时间类型来存储你的时间](https://laravel-china.org/topics/2495)  
3. 
## 

## 简介
最近在使用MySql数据库存储日期的时候，遇到了一些问题。前台传递了年月日，时分秒为空，后台程序处理的时候，转换为 `2016-11-21 00:00` 结果存入到数据库中之后，日期加了一天，可能是时区的问题。在网上查找资料，找到了一些关于MySql的日期字段的介绍，这里结合项目重新构思一下，日期怎样处理才会简洁通用。

## 时区的概念
之所以有时区的概念是因为住在地球上不同地方的人看到太阳升起的时间是不一样的。我们假设北京人民在早上8:00看到了太阳刚刚升起，而此刻欧洲人民还在夜里，他们还需要再过7个小时才能看到太阳升起，所以，此刻欧洲人民的手表上显示的是凌晨1:00。如果你强迫他们用北京时间那他们每天看到日出的时间就是下午3点。

也就是说，东8区的北京人民的手表显示的8:00和东1区欧洲人民手表显示的1:00是相同的时刻：

    "2014-10-14 08:00 +8:00" = "2014-10-14 01:00 +1:00"

这就是本地时间的概念。

但是，在计算机中，如果用本地时间来存储日期和时间，在遇到时区转换的问题上，即便你非常清楚地知道如何转换，也非常麻烦，尤其是矫情的美国人还在采用夏令时。

所以我们需要引入“绝对时间”的概念。绝对时间不需要年月日，而是以秒来计时。当前时间是指从一个基准时间（1970-1-1 00:00:00 +0:00），到现在的秒数，用一个整数表示。

当我们用绝对时间表示日期和时间时，无论服务器在哪个时区，任意时刻，他们生成的时间值都是相等的。所有编程语言都提供了方法来生成这个时间戳，Java和JavaScript输出以毫秒计算的Long型整数，Python等输出标准的Unix时间戳，以秒计算的Float型浮点数，这两者转换只存在1000倍的关系。

实际上，操作系统内部的计时器也是这个标准的时间戳，只有在显示给用户的时候，才转换为字符串格式的本地时间。


#### MySql 日期类型简介
|日期类型|储存空间(byte)|日期格式|日期范围|
|:-|:-|:-|:-|
|datatime|8|YYYY-MM-DD HH:MM:SS|1000-01-01 00:00:00 ~ 9999-12-31 23:59:59|
|timestamp|4|YYYY-MM-DD HH:MM:SS|1970-01-01 00:00:00 ~ 2038-00-00 00:00:00|
|data|3|YYYY-MM-DD|1000-01-01 ~ 9999-12-31|
|year|1|YYYY|1901 ~ 2155|

1. datatime 占用的空间最大，可以存储的日期范围最大，是一个不错的选择，但是相对于timestamp来说，在时区处理方面没有那么方便。
2. timestamp 的时区处理，timestamp 会记录所存时间的时区，当你获取时间时候数据库会返回时间和对应的时区。带时区的好处是编程语言会根据时区之间的差异把日期转换为当前时区的时间。
3. 数据库默认使用系统的时区，更改系统时区数据库中已经存在的日期不会改变，但是从数据库获取时间的时候，获得的时间还是原来的时间，但是时区却会变为改变过的时区。

    比如：
    原来是东八区 2016-11-23 21:02 +08:00
    改编为UTC(0时区) 2016-11-23 21:02 +00:00

#### 可行的日期存储方案
##### 1. timestamp
 
当数据库存数的时间范围在 `2016-11-23 21:02 +08:00` 里面，且在项目周期内不会超越这个范围，可以使用 `timestamp` 十分方便，不用做过多的处理。 

##### 2. datetime （不推荐）
`datetime` 基本可以满足所有的时间需求，由于 `datetime` 不包含时区，因此在数据入库的时候需要先把日期转换为一个标准时区对应的日期，获取日期的时候再把标准时区对应的日期转换为本地时区。时间的转换会比较复杂，特别是对于使用夏时令的地方的日期。

##### 3 使用bigint存储(-2^63 ~ 2^63)(9,223,372,036,854,775,807)
把时间对应的绝对时间（从标准时间开始到现在的毫秒数）存入数据库中，在使用时间的时候再把毫秒数转换为对应的日期字符串。这样就没有时区的概念，方便简洁。缺点是数据库中存的时间是毫秒数，查看数据库无法直观的看出对应的日期。


#### 一个时区时间的小测试

    //数据库所在时区为UTC
    数据库时间
    11-09 00:00
    11-18 00:00

    局域网机器 东八区
    11-09  08:00 1478649600000
    11-18  08:00 1479427200000
    
    本机(UTC)数据库在这里
    11-09  00:00 1478649600000
    11-18  00:00 1479427200000
    


    //数据库所在时区为东八区
    数据库时间
    11-09 00:00
    11-18 00:00

    本机东八区数据库在这里
    11-09  00:00 1478620800000
    11-18  00:00 1479398400000

    局域网机器 东八区
    11-09  00:00 1478620800000
    11-18  00:00 1479398400000
        
