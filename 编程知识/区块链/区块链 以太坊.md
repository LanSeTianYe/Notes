时间：2022-07-16 10:39:39

参考：

1. [go-ethereum](https://github.com/ethereum/go-ethereum)
2. [rinkebyfaucet](https://rinkebyfaucet.com/)
3. [private-network](https://geth.ethereum.org/docs/interface/private-network)
4. [remix](https://remix.ethereum.org/)

## 区块链 以太坊

### 节点类型

#### 全节点

存放全部数据，对块和交易进行验证。

#### 轻节点

不存链上历史数据，只保存区块当前状态。可以对区块和交易进行验证。

#### 远程客户端

不存历史数据，不验证区块和交易，只发起交易。如 `MetaMask`。

### 网络类型

#### 主网络

以太坊主网络，实际运行的以太坊网络。目前交易的 `ETH/ETC` 都在主网络上，

#### 测试网络

以太坊测试网络，模拟运行的以太坊网络，可以在上面部署合约测试以太坊的功能。里面的数据没有实际价值。

##### 水龙头  faucet

水龙头可以发放以太，可以从里面提取以太到自己钱包地址。可以在 `MetaMask` 里面找到水龙头的地址。

####　私有网络

本地启动以太网客户端，不连接到主网络。可以在控制台和链交互。

```
# 启动节点
./geth --datadir data --networkid 12345 --http --http.addr "192.168.0.201" --http.vhosts "*" --allow-insecure-unlock

# 交互控制台
./geth --datadir data attach
```

### 账户 

每个账户包含余额，以及代码和存储。比特币里面对应 UTXO（User Transactions Output）。

分一般账户和合约账户，都用地址标识，账户里面都有以太币。向普通账户发送交易即转账，向合约账户发送交易即调用合约。

### 交易

`nonce` 类似于版本号，nonce 等于每个节点已经发送的交易数量，用于保证每个交易只执行一次。nonce 的引入带来了并发的问题，因为要求交易的nonce是递增的，就导致交易必须一笔接一笔的被确认。

### 虚拟机

在内存中运行，不使用寄存器。

* 执行只能合约。
* 验证交易。

### 合约

合约数据可以保存在内存中，也可以持久化存储到磁盘中。

### Solidity
面向合约的语言。可以通过 Remix 在线编写。

**存取数据合约：**

```solidity
// SPDX-License-Identifier: GPL-3.0


pragma solidity >=0.7.0 <0.9.0;

/**
 * @title Storage
 * @dev Store & retrieve value in a variable
 * @custom:dev-run-script ./scripts/deploy_with_ethers.ts
 */
contract Storage {

    uint256 number;

    /**
     * @dev Store value in variable
     * @param num value to store
     */
    function store(uint256 num) public {
        number = num;
    }

    /**
     * @dev Return value 
     * @return value of 'number'
     */
    function retrieve() public view returns (uint256){
        return number;
    }
}
```

### 发币合约

```solidity
// SPDX-License-Identifier: GPL-3.0

pragma solidity > 0.4.22;

contract Coin {
    //铸币人 地址类型 
    address public minter;

    //映射 地址类型到 uint 类型
    mapping(address => uint) balanceMap;

    event Sent(address from, address to, uint amount);

    constructor() {
        //铸币人等于合约创建者
        minter = msg.sender;
    }

    //发币
    function mint(address receiver, uint amount) public {
        //条件判断
        require(msg.sender == minter);
        balanceMap[receiver] += amount;
    }

    //转币
    function send(address receiver, uint amount) public {
        require(balanceMap[msg.sender] >= amount);
        balanceMap[msg.sender] -= amount;
        balanceMap[receiver] += amount;
        //发送事件，类似于log
        emit Sent(msg.sender, receiver, amount);
    }

}
```

### ABI (Application Binary Interface)
由合约编译之后生成。 

### DAPP

Swarm协议、Web3、Whisper 协议。