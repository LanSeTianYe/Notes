## 空间换时间
用物理存储换来数据库操作(增、删、改、查)时间的优化，多通过使用中间表来完成。

1. 数据分析  
假如系统需要对原始数据进行一些分析，然而由于需要分析的数据量很大，查询分析要耗费大量的时间，我们可以根据一定的规则，把一些分析的结果存入到数据库中。当有请求的时候，我们可以先从结果集数据库中查询，如果没有对应的结果的时候再从原始数据库中查询分析。

2. 短信，邮件发送  （[内容来源](http://www.cnblogs.com/gaizai/archive/2010/03/30/1700312.html)）
    1. 基本做法：把数据存入到一张表中，所有的操作都在一张表上进行，会出现性能、锁表等问题。
    2. 高效但费空间的做法。
把 Insert、Delete和Update等操作分离在不同的表中。设计图如下：
![](http://images.cnblogs.com/cnblogs_com/gaizai/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1%E9%80%BB%E8%BE%912.jpg)

**流程描述：**  

1. 系统生成批量需要发送的短信数据，如果数据量不大直接存储在 `Tb_NotSend` 表中，如果数据量大的情况下，先把数据放入 `Tb_NotSend_buffer` 表中，然后一次性将 `Tb_NotSend_buffer` 表里面的数据插入到 `Tb_NotSend` 表中。插入完成后及时清理 `Tb_NotSend_buffer` 表中的数据。
2. 消息发送服务器从 `Tb_NotSend` 表读取需要发送的消息，同时修改 `Tb_NotSend` 表中信息的状态，然后邮件发送服务器发送消息，发送之后把已经发送的消息存到 `Tb_Send` 和 `Tb_outbox` 表中，。
3. 利用空闲时间对比 `Tb_Sent` 和 `Tb_NotSent` 表中的数据，删除 `Tb_NotSend` 和 `Tb_Sent` 表中的数据。

**每张表的作用：**

Tb_NotSent_buffer：待发送短信缓存表(即时清理)  

> 该表是为了避免应用过多对Tb_NotSent同时操作产生锁表情况。  
> 主要考虑到产生待发短信的逻辑通常会比较复杂,或者长事务。  
> 一次性将已经在buffer表里的短信insert到Tb_NotSent,这次插入没有长事务计算,由一条insert from select完成。  
> 该表并非一定用到,视产生待发短信的逻辑的事务复杂度,和量而定。  

Tb_NotSent：待发送的短信(会被定时清理)
> 会将该已经发送的短信的处理结果存储在jms消息队列里。  
> 把这些数据从Tb_NotSent copy到Tb_outbox同时,插一条记录到Tb_Sent.这样作是为了下一步删除Tb_NotSent里已经发送的信息.同时又不因为删除而锁Tb_NotSent表(应用使用)  
> 使用空间换时间的思想,减少对同一张表(Tb_outbox)的过多操作和过程时间的操作,导致锁表出现系统瓶颈。

Tb_outbox：存储历史记录的主表,该表需建立在独立的数据库
> 减少备份文件大小，可灵活调整,大大减少备份空间的需求。  
> 减少对主数据库的影响。

Tb_Sent：一个参照表，为删除Tb_NotSent表做基表

> 已经发送短信(会定时清理),存放已经被网关处理的短信(发送成功或者失败)。  
> 这个表不一定要保存和Tb_NotSent一样多的字段，也许只要两个字段，那就是ID值和状态值。  
> 保证了只有发送过的才会从 Tb_NotSend 中删除，根据状态判断可能会删除正在发送的短信。  