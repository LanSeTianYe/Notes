## Executors  
CachedThreadPool 在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的Executor的首选。另外还有 FixedThreadPool 和 SingleThreadPool。

## 从任务重返回值

	public class TaskWithResult implements Callable<String>{
	
	    private int id;
	
	    public TaskWithResult(int id) {
	        this.id = id;
	    }
	
	
	    @Override
	    public String call() throws Exception {
	        Thread.yield();
	        return "TaskWithResult id is:" + id;
	    }
	
	    public static void main(String[] args) throws ExecutionException, InterruptedException {
	        ExecutorService executorService = Executors.newCachedThreadPool();
	
	        Future<String> result = null;
	        for (int i = 0; i < 5; i++ ) {
	            result = executorService.submit(new TaskWithResult(i));
	            while (!result.isDone()) {
	                System.out.println("doing ....");
	            }
	            System.out.println(result.get());
	        }
	
	    }
	}

## 任务的优先级
任务的优先级会影响任务的执行频率，高优先级的任务并不一定限于低优先级的任务完成。

## daemon 后台线程
当所有的非后台线程结束时，程序就停止了，同时会杀死进程中的所有后台线程。

## yield 让步
让出所占的资源，让其他的线程先执行

## synchronized 资源同步
为了防止多线程使用同一个资源，产生资源竞争问题，在使用该资源的方法上添加  `synchronized` 关键字。然后调用对象的同步方法的线程在调用方法之前会先判断方法是否正在被调用，如果是的话就等待，发达调用完成之后再调用。

## Lock 对象实现同步
显示的加锁机制，使用起来更加灵活，可以控制获取锁的时间等，如果方法有返回值，需要在 `try` 块里面返回，在finally里面释放锁,代码如下:

	boolean captured = lock.tryLock();
    try {
        System.out.println("tryLock()" + captured);
    } finally {
        if(captured) {
            lock.unlock();
        }
    }
## 尽量不用 volatile

## 同步块控制

	public void test(){
		//不需要同步控制的代码
		synchronized(this){
			//需要同步控制的代码
		}
		//不需要同步控制的代码
	}