## Executors  
CachedThreadPool 在程序执行过程中通常会创建与所需数量相同的线程，然后在它回收旧线程时停止创建新线程，因此它是合理的Executor的首选。另外还有 FixedThreadPool 和 SingleThreadPool。

## 从任务重返回值

	public class TaskWithResult implements Callable<String>{
	
	    private int id;
	
	    public TaskWithResult(int id) {
	        this.id = id;
	    }
	
	
	    @Override
	    public String call() throws Exception {
	        Thread.yield();
	        return "TaskWithResult id is:" + id;
	    }
	
	    public static void main(String[] args) throws ExecutionException, InterruptedException {
	        ExecutorService executorService = Executors.newCachedThreadPool();
	
	        Future<String> result = null;
	        for (int i = 0; i < 5; i++ ) {
	            result = executorService.submit(new TaskWithResult(i));
	            while (!result.isDone()) {
	                System.out.println("doing ....");
	            }
	            System.out.println(result.get());
	        }
	
	    }
	}

## 任务的优先级
任务的优先级会影响任务的执行频率，高优先级的任务并不一定限于低优先级的任务完成。

## daemon 后台线程
当所有的非后台线程结束时，程序就停止了，同时会杀死进程中的所有后台线程。

## yield 让步
让出所占的资源，让其他的线程先执行
